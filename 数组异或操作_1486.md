## description
![image](https://github.com/ethan686/leetcode/assets/73508499/9543686e-ac38-466e-9e31-6aa7abd2d984)
## self_solution
```
class Solution {
public:
    int xorOperation(int n, int start) {
        int res = 0;
        for(int i = 0; i < n; i++) {
            res ^= (start + 2 * i);
        }
        return res;
    }
};
```
## 数学方法(直接用题解 + 部分个人理解)
上述解法数据范围出到10^8大概率会发生 TLE。
事实上，本题存在「数学规律」解法。

原式子为 start ⊕ (start + 2) ⊕ (start + 4) ⊕ ... ⊕ (start + 2 * (n - 1))
我们发现原式子中只有数值 2 是固定系数（由题目给定），考虑将其进行提出。
得到新式子 (s⊕(s+1)⊕(s+2)⊕...⊕(s+(n−1)))∗2 ，其中 s=start/2。
之所以进行这样的转换操作，是因为我们想要利用 1⊕2⊕3=0 的异或性质。(这样就贴近到1 2 3了，只是前面加项不一定。 注意 2 4 6 并不能实现异或为0)

但是转换到了这一步，我们发现「新式子」与「原式子」其实并不相等。
我们需要考虑两者之间的差值关系：
不难发现，将「原式」转化成「新式」的集体除以2的操作相当于将每个item进行「右移一位」，同时「异或运算」是每位独立计算的，因此「右移一位」不会影响移动部分的计算结果。
本质上，「原式」转化成「新式」是将最终答案 ans 进了「右移」一位的操作。因此如果要重新得到 ans，我们需要将其重新「左移」一位，将最后一位异或结果补回。(666666)

即 原式结果 = 新式结果 << 1 再补上一个e，e 为最后一位异或结果（只能是 0 或者1）。

我们重新观察「原式」发现式子中每个item奇偶性相同，这意味着其二进制的最低位相同。

根据 n 和 start 的奇偶数搭配，不难得最后一位 e = n & start & 1。 只有n和start都是奇数的时候，全都异或起来的最后一位才是1。 所以直接这三个的与 可以直接代表

剩下的问题在于如何在不遍历的情况下计算「新式」结果，前面说到转化的目的是为了利用 1⊕2⊕3=01 ⊕ 2 ⊕ 3 = 01⊕2⊕3=0 异或特性。

事实上，这个式子存在一般性的推广结论：4i⊕(4i+1)⊕(4i+2)⊕(4i+3)=04i ⊕ (4i + 1) ⊕ (4i + 2) ⊕ (4i + 3) = 04i⊕(4i+1)⊕(4i+2)⊕(4i+3)=0。

因此只需要对最后一项进行 %4 讨论即可，这部分属于「结论」，详见代码的 calc 部分。

总结一下，假设我们最终的答案为 ans。整个处理过程其实就是把原式中的每个 item右移一位（除以 2），计算 ans 中除了最低一位以外的结果；然后再将 ans 进行一位左移（重新乘以 2），将原本丢失的最后一位结果重新补上。补上则是利用了 n 和 start 的「奇偶性」的讨论。


而我们要求 (s ^ (s+1) ^ (s+2) ^ …… ^ (s+n-1)) * 2 + e
由定理有 x ⊕ x ⊕ y = y，即(s ^ (s+1) ^ (s+2) ^ …… ^ (s+n-1)) = （1 ^ 2 ^ 3 ^ …… ^ s - 1)(1 ^ 2 ^ 3 ^ …… ^ s - 1 ^ s ^ (s+1) ^ (s+2) ^ …… ^ (s+n-1));

对于（1 ^ 2 ^ 3 ^ …… ^ s - 1) 相当于 （0^ 1 ^ 2 ^ 3 ^ …… ^ s - 1) 我们可以认为有多对 0 1 2 3 只需要看一下最后一个s-1的时候，是在一个新的0 新的1 新的2还是新的3
当然此时不单单是 0 1 2 3  可能是 4 5 6 7 或者whatever

如果当前s-1 % 4 == 0 说明位于一个新的 0 1 2 3的开始，前面所有的数异或起来都是0 相当于 0 ^ s - 1 = s - 1
如果当前s-1 % 4 == 1 说明位于一个新的 0 1 2 3的1 。前面所有0 1 2 3异或起来都是0 然后0 异或了一个新的0 又异或了一个新的1，新的0 和新的1  其实只有最低位不同 所以结果为1
如果当前s-1 % 4 == 2 说明位于一个新的 0 1 2 3的2. 同理只有 0 1 2。新的0 1异或完之后是1  相当于1异或一个偶数。所以是偶数+1 即 s -1  +1
如果当前s-1 % 4 == 3 说明位于一个新的 0 1 2 3的3.那实际上这一组也完全体，返回0

同理(1 ^ 2 ^ 3 ^ …… ^ s - 1 ^ s ^ (s+1) ^ (s+2) ^ …… ^ (s+n-1));
```
class Solution {
public:

    int sumXor(int x) {
        if(x % 4 == 0) return x;
        if(x % 4 == 1) return 1;
        if(x % 4 == 2) return x + 1;
        return 0;
    }

    int xorOperation(int n, int start) {
        int lastBit = n & start & 1;
        int s = start >> 1;
        int res = sumXor(s - 1) ^ sumXor(s + n - 1);
        res = res << 1 | lastBit;
        return res;
    }
};
```
